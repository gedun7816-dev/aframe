<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>互動 AR 模型範例</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.rawgit.com/AR-js-org/AR.js/3.3.2/aframe/build/aframe-ar.js"></script>
</head>
<body style="margin:0; overflow:hidden;">

<a-scene embedded arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">
  
  <a-marker type="pattern" url="marker.patt">

    <!-- 模型 -->
    <a-entity id="model"
              gltf-model="asset.glb"
              scale="0.5 0.5 0.5"
              rotation="0 0 0"
              visible="false"
              gesture-handler
              auto-rotate-float
              clickable-scale>
    </a-entity>

    <!-- 載入提示 -->
    <a-text id="loading-text" value="Loading..." color="#FFF" position="0 0 0" align="center"></a-text>

  </a-marker>

  <a-entity camera></a-entity>

</a-scene>

<script>
  // 手勢控制 + 載入提示 + 自動縮放
  AFRAME.registerComponent('gesture-handler', {
    init: function () {
      const model = this.el;
      const loadingText = document.querySelector('#loading-text');

      model.addEventListener('model-loaded', () => {
        model.setAttribute('visible', 'true');
        loadingText.setAttribute('visible', 'false');

        // 自動縮放
        const bbox = new THREE.Box3().setFromObject(model.getObject3D('mesh'));
        const size = bbox.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scaleFactor = 1 / maxDim;
        model.object3D.scale.set(scaleFactor, scaleFactor, scaleFactor);
        model.setAttribute('data-original-scale', scaleFactor);
      });

      // 手動旋轉
      let isDragging = false;
      let previousX = 0;
      const canvas = model.sceneEl.canvas;

      canvas.addEventListener('mousedown', e => { isDragging = true; previousX = e.clientX; });
      canvas.addEventListener('mouseup', () => { isDragging = false; });
      canvas.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const deltaX = e.clientX - previousX;
        previousX = e.clientX;
        model.object3D.rotation.y += deltaX * 0.005;
      });

      // 觸控旋轉
      canvas.addEventListener('touchstart', e => { isDragging = true; previousX = e.touches[0].clientX; });
      canvas.addEventListener('touchend', () => { isDragging = false; });
      canvas.addEventListener('touchmove', e => {
        if (!isDragging) return;
        const deltaX = e.touches[0].clientX - previousX;
        previousX = e.touches[0].clientX;
        model.object3D.rotation.y += deltaX * 0.005;
      });
    }
  });

  // 自動旋轉 + 浮動
  AFRAME.registerComponent('auto-rotate-float', {
    schema: { speed: { type: 'number', default: 0.5 }, floatHeight: { type: 'number', default: 0.05 } },
    init: function () {
      this.originalY = this.el.object3D.position.y;
      this.clock = new THREE.Clock();
    },
    tick: function () {
      const delta = this.clock.getElapsedTime();
      this.el.object3D.rotation.y += this.data.speed * 0.01;
      this.el.object3D.position.y = this.originalY + Math.sin(delta) * this.data.floatHeight;
    }
  });

  // 點擊模型放大/縮小
  AFRAME.registerComponent('clickable-scale', {
    init: function () {
      const el = this.el;
      el.addEventListener('click', () => {
        const originalScale = parseFloat(el.getAttribute('data-original-scale'));
        const currentScale = el.object3D.scale.x;
        if (currentScale <= originalScale + 0.01) {
          el.object3D.scale.set(originalScale*2, originalScale*2, originalScale*2);
        } else {
          el.object3D.scale.set(originalScale, originalScale, originalScale);
        }
      });
    }
  });
</script>

</body>
</html>
